# makeCacheMatrix and cacheSolve, when used together, will store the inverse of
# a matrix that has already been calculated, and return the stored value if the user
# attempts to take the inverse of the same matrix two or more times in a row


## makeCacheMatrix takes an (assumed invertible) matrix and creates a list of
## functions to be used by the function cacheSolve
makeCacheMatrix <- function(x = matrix()){
        i <- NULL #if makeCacheMatrix is called, i defaults to NULL
        set <- function(y){ ##this function can be called by the user to input a new matrix
                x <<- y ##set the value of x to the new matrix that the user has provided
                i <<- NULL ##since a new matrix is provided, i must again be defaulted to NULL
        }
        get <- function() x ##to be called by cacheSolve to retrieve a newly supplied matrix
        setinv <- function(inv) i <<- inv ##setinv will be called by cacheMatrix after the inverse has been calculated to set the newly calculated inverse matrix
                                          ##if the inverse has already been calculated, cacheSolve will not get this far and setinv won't be called
        getinv <- function() i ##called by cacheSolve to check if the inverse has already been cached
        list(set = set, get = get, setinv = setinv, getinv=getinv) ##create the list of functions returned by makeCacheMatrix
}


## This function uses the list of functions generated by makeCacheMatrix to check if inverse of the matrix has already been calculated
## If the inverse has already been calculated, a message is returned and the inverse is returned without re-doing the calculation
## Otherwise, cacheSolve calculates and returns the inverse
cacheSolve <- function(x) {
        
        i <- x$getinv() ##retrieve the matrix that has been set, if there is one
        if(!is.null(i)){ ##if there is a matrix already set, do not re-do calculation and return the stored inverse matrix
                message("getting cached data")
                return(i)
        }
        data <- x$get() ##otherwise, calculate the inverse and store it in cacheSolve
        i <- solve(data)
        x$setinv(i)
        i ##return the newly inverse
}
